from org.bukkit import Material
from org.bukkit.event.block import Action
from org.bukkit import Location
from org.bukkit import ChatColor
from java.lang import Runnable

import yaml
import os
import time
import math
import random



##### hooks below here #####
@hook.enable
def onEnable():
    state.load()
    if not os.path.exists(state.get_path('state.yml')):
        #no state file, create a blank one
        with open(state.get_path('state.yml'),'w') as st:
            st.write(yaml.dump({}))
    #check if dragon_lands was re-generated by external helper script:
    if os.path.exists(state.get_path('regenerated_flag_file')):
        state.set('zone',None)
        log('regeneration flag detected, resetting zone and logged out time counter')
        state.load()
        os.remove(state.get_path('regenerated_flag_file'))
    log("Enabled v:%s!"%(info.getVersion()) )

@hook.disable
def onDisable():
    log("Disabled v:%s!"%(info.getVersion()))

@hook.command("dragon")
def onCommand(sender, command, label, args):
    #log("command:%s  <><> label:%s  <><> args:%s"%(command,label,args))
    
    if not sender.hasPermission("dragon_lands.command.base"):
        #not allowed to run base command
        return False
    if command.getName() == 'dragon':
        if len(args)==0:

            #base command, try and teleport to new world:
            ploc = sender.getLocation()
            if math.hypot(ploc.getX() - state.zone['x'] ,ploc.getZ() -state.zone['z']) <\
                            int(state.config['settings']['zone']['size']):
                sender.sendMessage(random.choice(state.config['strings']['teleport'])['string'])

                if state.zone['enter_time'] is None:
                    state.zone['enter_time'] = time.time()
                    log('dragon lands entered for the first time')
                log('dragon command executed and within range')
                loc = server.getWorld('dragon_lands').getSpawnLocation()
                sender.teleport(loc)
            else:
                sender.sendMessage(random.choice(state.config['strings']['toofar'])['string'])
            
        if len(args)==1:
            if args[0] == 'reload':
                if not sender.hasPermission("dragon_lands.command.reload"):
                    return False
                #reload the configuration
                state.load()
            elif args[0] == 'regen':
                if not sender.hasPermission("dragon_lands.command.regen"):
                    return False
                #TODO::: regenerate the world
                state.set('zone',None)
                log('regeneration requested!')
                state.load()

        return True#says that command executed "successfully"


@hook.event("player.PlayerInteractEvent")
def onPlayerInteract(event):
    p=event.getPlayer()
    if not p.getWorld().getName() == state.config['settings']['guide']['active_world_name']:
        #not in the correct world, bail out!
        return
    if not p.hasPermission("dragon_lands.interact_event"):
        return
    if p.getItemInHand().getType() == getattr(Material,state.config['settings']['guide']['itemMaterial']):

        if event.getAction() == Action.RIGHT_CLICK_AIR or event.getAction() == Action.RIGHT_CLICK_BLOCK:
            event.setCancelled(True)
            ploc = p.getLocation()
            dist = math.hypot(ploc.getX() - state.zone['x'] ,ploc.getZ() -state.zone['z'])
            abs_theta = math.atan2(ploc.getZ() -state.zone['z'],ploc.getX() - state.zone['x'])
            yaw = ploc.getYaw() +90
            while yaw > 180 or yaw < -180:
                if   yaw > 180:
                    yaw -= 360
                elif yaw < -180:
                    yaw += 360

            theta = math.degrees(math.radians(yaw) - abs_theta) + 180
            while theta > 180 or theta < -180:
                if   theta > 180:
                    theta -= 360
                elif theta < -180:
                    theta += 360
            #p.sendMessage("dist:%s  theta:%s, yaw:%s, abs_theta:%s"%(dist,theta,yaw,math.degrees(abs_theta)))
            p.sendMessage("%s%s%s"%(ChatColor.GRAY,ChatColor.ITALIC,get_msg(dist,theta,p.getName())))


@hook.event("player.PlayerJoinEvent")
def onPlayerJoin(event):
    if in_dragon_lands(event):
        getout = state.get('players.getout.%s'%event.getPlayer().getName())
        if getout is not None:
            tdelta = time.time() - state.zone['spawn_time']
            log('time delta of zone-gen:%s'%tdelta)
            #if tdelta > state.config['settings']['zone']['regen_timeout']:
                #greater than the timeout (been away for too long...) get the player somewhere 'safe'

            if state.get('players.getout.%s'%event.getPlayer().getName()) < state.get('zone.spawn_time'):
                #they logged out of the world BEFORE the current generation, respawn them.
                if state.config['settings']['respawn']['spawn_at_loc']:
                    loc = Location(server.getWorld(state.config['settings']['respawn']['world_name']),
                        state.config['settings']['respawn']['x'],
                        state.config['settings']['respawn']['y'],
                        state.config['settings']['respawn']['z']
                        )
                else:
                    loc = server.getWorld(state.config['settings']['respawn']['world_name']).getSpawnLocation()

                event.getPlayer().teleport(loc)
            #set getout to none, we always reset it on log-out anywho if we need it. this clears up who is still in dragonlands
            state.set('players.getout.%s'%event.getPlayer().getName(),None)

@hook.event("player.PlayerQuitEvent")
def onQuitJoin(event):
    if in_dragon_lands(event):
        state.set('players.getout.%s'%event.getPlayer().getName(),time.time())

@hook.event("player.PlayerChangedWorldEvent")
def onPlayerChangeWorld(event):
    #hacky fix to make sure they spawn on the island, multiverse is messing up?
    if event.getPlayer().getWorld().getName() == 'dragon_lands_the_end':
        log("fixing teleport, %s /tp'd to end spawn"%event.getPlayer().getName())
        class task(Runnable):
            '''have to use a delayed task due to teleporting so soon after world moving
            server complains about moving too fast otherwise.'''
            def run(self):
                server.dispatchCommand(server.getConsoleSender(), "mv tp %s dragon_lands_the_end"%event.getPlayer().getName())
        server.getScheduler().runTaskLater(pyplugin,task(),20)
        #server.dispatchCommand(server.getConsoleSender(), "mv tp %s dragon_lands_the_end"%event.getPlayer().getName())
        #event.getPlayer().teleport(event.getPlayer().getWorld().getSpawnLocation())




def in_dragon_lands(event):
    return event.getPlayer().getWorld().getName() in (
        'dragon_lands','dragon_lands_nether','dragon_lands_the_end')

def log(msg):
    pyplugin.getLogger().info(msg)




class State(object):
    ''' 
    config:
        is a read-only configuration dictionary that is read from config.yml

    guide:
        dictionary of player:{last_msg_type: so we don't repeat ourselves
                              last_dd_time: last time a direction/distance message was sent 
                                    This makes sure a player gets lore during the cool down of the dd timer
                              }

    zone:
        x,z: location of the center of the zone
        spawn_time: when the zone was generated
        [enter_time=None]: when the zone was "entered" for the first time (/tp'd to dragon_lands)



    '''

    config = None
    guide = {}
    path = os.path.join('plugins','DragonLands.py.dir')
    zone = None



    def get_path(self,name):
        return os.path.join(self.path,name)

    def load(self):
        #first, check everything is "empty"
        self.config = None
        self.guide = {}

        #load some thingies
        with open(self.get_path('config.yml')) as cfg:
            self.config = yaml.load(cfg)

        self.zone = self.get('zone')
        if self.zone is None:
            self.zone={}
            theta = random.uniform(0,2*math.pi)
            r=random.randint(1000,9001)
            self.zone['x']=int(r*math.cos(theta))
            self.zone['z']=int(r*math.sin(theta))
            self.zone['spawn_time']=time.time()
            self.zone['enter_time']=None
            self.set('zone',self.zone)
            log('generating zone state: x=%s z=%s'%(self.zone['x'],self.zone['z']))
        log('zone state: x=%s z=%s'%(self.zone['x'],self.zone['z']))
        log('zone-state and configuration loaded')

    def save(self):
        '''save state (all of it) including cached sate like self.zone'''
        pass#TODO::: actually save detailed state?
    def set(self, path, value):
        '''set the persistance/state.yml value at $path to $value'''
        path=str(path)
        def crawl_set(dt,path,value):
            if isinstance(path, (str,unicode)):
                path=path.split('.')
            if len(path)==1:
                if isinstance(value, (str,unicode)):
                    value=str(value)
                dt[path[0]]=value
            else:
                if path[0] not in dt:
                    dt[path[0]]={}
                crawl_set(dt[path[0]],path[1:],value)

        with open(self.get_path('state.yml')) as st:
            tmp_state = yaml.load(st)

        if tmp_state == None:
            tmp_state={}

        crawl_set(tmp_state, path, value)
        
        with open(self.get_path('state.yml'),'w') as st:
            st.write(yaml.dump(tmp_state))


    def get(self, path):
        path=str(path)
        def crawl_get(dt,path):
            if isinstance(path, (str,unicode)):
                path=path.split('.')
            if len(path)==1:
                return dt.get(path[0],None)
            else:
                if path[0] not in dt:
                    return None
                return crawl_get(dt[path[0]],path[1:])

        with open(self.get_path('state.yml')) as st:
            tmp_state = yaml.load(st)
        return crawl_get(tmp_state, path)

state = State() #only ever one, so make sure anything interesting is saved to disk



def get_msg(dist,theta,player):

    types = ('directions','distance','lore')#message types that are available via right-click
    
    ty=random.choice(types)
    if player not in state.guide:
        state.guide[player]={'last_type':ty,'last_dd_time':0}
    
    #check for timeout on d/d vs lore messages
    if time.time() - state.guide[player]['last_dd_time'] < state.config['settings']['guide']['cool_down']:
        ty = 'lore'
    else:
        state.guide[player]['last_dd_time']=time.time()
    messages = state.config['strings'][ty]


    #cut all low-bound and high-bound messages
    good_msgs=[]
    if ty == 'distance':
        for msg in messages:
            if msg['min'] < dist and msg['max'] > dist:
                good_msgs.append(msg)
        msg = random.choice(good_msgs)['string']
        if state.config['settings']['guide']['show_distance'] ==True:
            msg = msg + "%s%s Distance:%s"%(ChatColor.RESET,ChatColor.LIGHT_PURPLE,int(dist))
    elif ty == 'directions':
        for msg in messages:
            if msg['min'] < theta and msg['max'] > theta:
                good_msgs.append(msg)
        def delta_theta(msg):
            min_bound = abs(msg['min'] - theta)
            max_bound = abs(msg['max'] - theta)
            return min((min_bound,max_bound))

        msg = min(good_msgs,key=delta_theta)['string']
        if state.config['settings']['guide']['show_angle'] ==True:
            msg = msg + "%s%s Angle:%s"%(ChatColor.RESET,ChatColor.LIGHT_PURPLE,int(theta))
    else: 
        #bail out now! no complicated choicing needed
        msg = random.choice(messages)['string']

    return msg
